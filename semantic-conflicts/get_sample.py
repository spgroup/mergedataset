import sys
import os
import csv
import argparse

def fetchJars(getSerialized):
    outputPath = os.getcwd()
    merge_scenarios_directory = outputPath.split("semantic-conflicts")[0]
    merge_scenarios_file = "results-only.csv"

    print("Starting getting jars...")
    parsedOutput = read_output(merge_scenarios_file)
    print(len(parsedOutput))
    new_output = ""
    # download the releases for the project moving them to the output directories
    for key in parsedOutput:
        # check if release was generated by the framework
        try:
            values = parsedOutput[key].split(",")
            commitSHA = values[1]
            new_output += get_version_for_commit(merge_scenarios_directory, commitSHA, "original", values)
            new_output += get_version_for_commit(merge_scenarios_directory, commitSHA, "transformed", values)
            if getSerialized:
                new_output += get_version_for_commit(merge_scenarios_directory, commitSHA, "serialized", values)
        except Exception as e:
            print(key)
            print(parsedOutput[key])
            print(e)
    create_final_output_file(outputPath, new_output)

def get_version_for_commit(outputPath, commitSHA, version, values):
    target_method_name = values[6].split('(')[0]
    release = get_local_jars_for_commit(outputPath, commitSHA, version, values[0])
    if (release == ""):
        return release
        
    base_jars_list = get_all_jars_for_revision(release, "base")
    base = jars_list_to_string(base_jars_list, version, target_method_name)
    
    left_jars_list = get_all_jars_for_revision(release, "left")
    left = jars_list_to_string(left_jars_list, version, target_method_name)
    
    right_jars_list = get_all_jars_for_revision(release, "right")
    right = jars_list_to_string(right_jars_list, version, target_method_name)
    
    merge_jars_list = get_all_jars_for_revision(release, "merge")
    merge = jars_list_to_string(merge_jars_list, version, target_method_name)
    
    return format_output(values, merge, left, right, base, version)

def jars_list_to_string(jars_list, version, target_method_name):
    if (version == 'serialized'):
        jars_list = [jar for jar in jars_list if target_method_name in jar]
    return ':'.join(jars_list)

def create_final_output_file(outputPath, contents):
   with open(outputPath + "/results_semantic_study.csv", 'w') as outputFile:
        outputFile.write(contents)
        outputFile.close() 

def create_final_output_file_object(outputPath, contents):
   with open(outputPath + "/results_semantic_study.csv", mode='a+') as employee_file:
    employee_writer = csv.writer(employee_file, delimiter=';', quoting=csv.QUOTE_MINIMAL)
    employee_writer.writerow(contents)

def format_output(values, merge, left, right, base, version):
    jars_available = "true"
    if (merge == "" and base == "" and (left == "" or right == "")):
        jars_available = "false"

    return values[0]+","+jars_available+","+values[1]+","+values[2]+","+values[3]+","+values[4]+","+values[5]+","+values[6]+","+values[7]+","+values[8]+","+base+","+left+","+right+","+merge+","+version+",\n"

def read_output(outputPath):
    try:
        fo = open(outputPath)
        file = fo.read()
        fo.close()

        fileOutLines = file.split("\n")
        return parse_output(fileOutLines)
    except Exception as e:
        print(e)

def parse_output(lines):
    result = {}
    for line in lines[1:]:
        cells = line.split(",")
        if (len (cells) > 1):
            result[cells[1]+"-"+cells[5]+"-"+cells[6]] = line
    return result

def get_local_jars_for_commit(path, commit, directory, projectName):
    local_jars_directory = '/'.join([path[:-1], projectName, commit, directory])
    if (os.path.isdir(local_jars_directory)):
        return local_jars_directory
    else:
        if 'serialized' in directory:
            print(f"\033[93m WARNING: folder {local_jars_directory} not found!")
        else:
            print(f"\033[91m ERROR: folder {local_jars_directory} not found!")
        return ""

def get_all_jars_for_revision(path, revision):
    command = 'find '+str(path)+ '/'+str(revision)+' -name "*.jar"'
    jars = os.popen(command).read().split("\n")[:-1]
    return jars

parser = argparse.ArgumentParser(description='Get jars for the semantic conflicts study')
parser.add_argument('--serialized', help='Get serialized jars', default=False, action='store_true')
args = parser.parse_args()

# TODO: modificar isso antes de subir
fetchJars(True)