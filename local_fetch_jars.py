import sys
import os
import csv

#outputPath = sys.argv[1]
#merge_scenarios_file = sys.argv[2]

def fetchJars():#outputPath, merge_scenarios_file):
    outputPath = os.getcwd()
    merge_scenarios_file = "results-only.csv"

    print("Starting getting jars...")
    parsedOutput = read_output(merge_scenarios_file)
    new_output = ""
    # download the releases for the project moving them to the output directories
    for key in parsedOutput:
        # check if release was generated by the framework
        try:
            values = parsedOutput[key].split(",")
            commitSHA = values[1]
            release = get_local_jars_for_commit(outputPath, commitSHA, "original")
            base = get_all_jars_for_revision(release, "base")
            left = get_all_jars_for_revision(release, "left")
            right = get_all_jars_for_revision(release, "right")
            merge = get_all_jars_for_revision(release, "merge")
            new_output += format_output(values, merge, left, right, base)
        except Exception as e:
            print(key)
            print(e)
    create_final_output_file(outputPath, new_output)

def create_final_output_file(outputPath, contents):
   with open(outputPath + "/results_semantic_study.csv", 'w') as outputFile:
        outputFile.write(contents)
        outputFile.close() 

def create_final_output_file_object(outputPath, contents):
   with open(outputPath + "/results_semantic_study.csv", mode='a+') as employee_file:
    employee_writer = csv.writer(employee_file, delimiter=';', quoting=csv.QUOTE_MINIMAL)
    employee_writer.writerow(contents)

def format_output(values, merge, left, right, base):
    jars_available = "false"
    if (merge != "" and base != "" and (left != "" or right != "")):
        jars_available = "merge-conflict"

    return values[0]+","+jars_available+","+values[1]+","+values[2]+","+values[3]+","+values[4]+","+values[5]+","+values[6]+","+values[7]+","+values[8]+","+base+","+left+","+right+","+merge+","+values[9]+","+values[10]+","+values[11]+"\n"

def format_output_object(values, merge, left, right, base):
    jars_available = "false"
    if (merge != "" and base != "" and (left != "" or right != "")):
        jars_available = "true"

    return [values[0], jars_available, values[1], values[2], values[3], values[4], values[5], values[6].replace("|",","), values[7], values[8], base, left, right, merge, values[9], values[10], values[11]]

def read_output(outputPath):
    try:
        fo = open(outputPath)
        file = fo.read()
        fo.close()

        fileOutLines = file.split("\n")
        return parse_output(fileOutLines)
    except Exception as e:
        print(e)

def parse_output(lines):
    result = {}
    for line in lines[1:]:
        cells = line.split(",")
        if (len (cells) > 1):
            result[cells[1]+"-"+cells[5]] = line
    return result

def get_local_jars(path, directory):
    command = 'find '+str(path)+ ' -name ' +str(directory)
    return os.popen(command).read().split("\n")[:-1][0]

def get_local_jars_for_commit(path, commit, directory):
    command = 'find '+str(path)+ ' -name ' +str(commit)
    return get_local_jars(os.popen(command).read().split("\n")[:-1][0], directory)

def get_all_jars_for_revision(path, revision):
    command = 'find '+str(path)+ '/'+str(revision)+' -name "*.jar"'
    jars = os.popen(command).read().split("\n")[:-1]
    all_jars = ""
    for one_jar in jars:
        all_jars += str(one_jar)+str(":")
    return all_jars

fetchJars()#outputPath, merge_scenarios_file)